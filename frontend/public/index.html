<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Secret Color Vote</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
    <style>
      /* Premium dark theme variables reused from the original sample */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --bg-primary: #0a0b0f;
        --bg-secondary: #151821;
        --bg-tertiary: #1e2028;
        --accent-gold: #d4af37;
        --accent-cyan: #00d4ff;
        --text-primary: #ffffff;
        --text-secondary: #a1a1aa;
        --text-muted: #71717a;
        --border-primary: rgba(255, 255, 255, 0.08);
        --border-accent: rgba(212, 175, 55, 0.3);
        --glass-bg: rgba(255, 255, 255, 0.03);
        --glass-border: rgba(255, 255, 255, 0.06);
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 8px 32px rgba(0, 0, 0, 0.4);
        --shadow-lg: 0 16px 64px rgba(0, 0, 0, 0.5);
        --gradient-gold: linear-gradient(135deg, #d4af37 0%, #f6e27a 100%);
        --gradient-cyan: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
        --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
        --gradient-metamask: linear-gradient(135deg, #f6851b 0%, #e2761b 100%);
      }
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
      body {
        min-height: 100vh;
        font-family:
          "Inter",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background:
          radial-gradient(circle at 20% 20%, rgba(212, 175, 55, 0.05) 0%, transparent 50%),
          radial-gradient(circle at 80% 80%, rgba(0, 212, 255, 0.05) 0%, transparent 50%),
          linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        color: var(--text-primary);
        line-height: 1.6;
        overflow-x: hidden;
      }
      /* Fixed top bar with progress indicator */
      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 2rem;
        background: rgba(10, 11, 15, 0.8);
        backdrop-filter: blur(20px) saturate(180%);
        border-bottom: 1px solid var(--border-primary);
        box-shadow: var(--shadow-sm);
      }
      .topbar::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        height: 2px;
        width: 0%;
        background: var(--gradient-gold);
        transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .topbar.connected::after {
        width: 100%;
      }
      .logo {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 1.125rem;
        font-weight: 600;
        letter-spacing: -0.025em;
        color: var(--text-primary);
      }
      .logo img {
        height: 32px;
        filter: brightness(1.1);
      }
      /* MetaMask connect button */
      #connect {
        position: relative;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1.5rem;
        background: var(--gradient-metamask);
        border: 1px solid rgba(246, 133, 27, 0.3);
        border-radius: 12px;
        color: white;
        font-weight: 600;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: var(--shadow-sm);
        overflow: hidden;
      }
      #connect::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      #connect:hover::before {
        opacity: 1;
      }
      #connect:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
        border-color: rgba(246, 133, 27, 0.5);
      }
      #connect:focus {
        outline: 2px solid var(--accent-gold);
        outline-offset: 2px;
      }
      #connect:disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
      }
      #connect img {
        width: 20px;
        height: 20px;
      }
      /* Main content spacing */
      main {
        padding-top: 6rem;
        padding-bottom: 4rem;
        padding-left: 1rem;
        padding-right: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3rem;
      }
      /* Hero section */
      .hero {
        text-align: center;
        max-width: 800px;
        margin: 0 auto;
      }
      .hero h1 {
        font-size: clamp(2.5rem, 5vw, 4rem);
        font-weight: 700;
        letter-spacing: -0.05em;
        margin-bottom: 1rem;
        background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-gold) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .hero p {
        font-size: 1.25rem;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
      }
      .hero .subtitle {
        font-size: 0.875rem;
        color: var(--text-muted);
        font-family: "JetBrains Mono", monospace;
        text-transform: uppercase;
        letter-spacing: 0.1em;
      }
      /* Cards layout */
      .app {
        width: 100%;
        max-width: 1000px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        perspective: 1200px;
      }
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
          max-width: 500px;
        }
      }
      .card {
        position: relative;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 24px;
        padding: 2.5rem;
        backdrop-filter: blur(20px) saturate(180%);
        box-shadow: var(--shadow-md);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        transform-style: preserve-3d;
        overflow: hidden;
      }
      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--accent-gold), transparent);
        opacity: 0.6;
      }
      .card:hover {
        border-color: var(--border-accent);
        box-shadow:
          var(--shadow-lg),
          0 0 0 1px rgba(212, 175, 55, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
      .card h2 {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--accent-gold);
        margin-bottom: 1.5rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .card h2 i {
        font-size: 1.125rem;
      }
      /* Note and form styling */
      .note {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-bottom: 1.5rem;
        padding: 0.75rem 1rem;
        background: rgba(212, 175, 55, 0.05);
        border: 1px solid rgba(212, 175, 55, 0.1);
        border-radius: 8px;
        font-family: "JetBrains Mono", monospace;
      }
      .inputs {
        display: flex;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }
      @media (max-width: 600px) {
        .inputs {
          flex-direction: column;
        }
      }
      .input-wrapper {
        flex: 1;
      }
      label {
        display: block;
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
      }
      input[type="number"],
      input[type="text"],
      select {
        width: 100%;
        padding: 1rem 1.25rem;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--border-primary);
        border-radius: 12px;
        color: var(--text-primary);
        font-size: 1rem;
        font-family: "JetBrains Mono", monospace;
        text-align: center;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      input:focus,
      select:focus {
        outline: none;
        border-color: var(--accent-cyan);
        box-shadow:
          0 0 0 3px rgba(0, 212, 255, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        background: rgba(0, 0, 0, 0.4);
      }
      input:disabled,
      select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      /* Buttons */
      .btn {
        position: relative;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 1rem 1.5rem;
        border: none;
        border-radius: 12px;
        font-size: 0.875rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .btn::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .btn:hover::before {
        opacity: 1;
      }
      .btn:focus {
        outline: 2px solid var(--accent-gold);
        outline-offset: 2px;
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }
      .btn-primary {
        background: var(--gradient-gold);
        color: var(--bg-primary);
        box-shadow: var(--shadow-sm);
      }
      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }
      .btn-secondary {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        box-shadow: var(--shadow-sm);
      }
      .btn-secondary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }
      .btn-success {
        background: var(--gradient-success);
        color: white;
        box-shadow: var(--shadow-sm);
      }
      .btn-success:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }
      .btn i {
        font-size: 1rem;
      }
      /* Status section */
      .status {
        width: 100%;
        max-width: 1000px;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      #status,
      #result,
      #histogramResult {
        padding: 1.5rem 2rem;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 16px;
        backdrop-filter: blur(20px) saturate(180%);
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        text-align: center;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.875rem;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      /* Loading and encryption effects */
      .loading::after {
        content: "";
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: var(--accent-gold);
        border-radius: 50%;
        margin-left: 12px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .encrypt-animation {
        position: relative;
        overflow: hidden;
      }
      .encrypt-animation::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(0, 212, 255, 0.1) 20%,
          rgba(0, 212, 255, 0.3) 50%,
          rgba(0, 212, 255, 0.1) 80%,
          transparent 100%
        );
        animation: scan 2s ease-in-out infinite;
        border-radius: 12px;
      }
      @keyframes scan {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }
      .success-flash {
        animation: flash 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      @keyframes flash {
        0%,
        100% {
          box-shadow: var(--shadow-sm);
          border-color: var(--glass-border);
        }
        50% {
          box-shadow:
            var(--shadow-md),
            0 0 0 2px rgba(16, 185, 129, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
          border-color: rgba(16, 185, 129, 0.5);
        }
      }
      .card {
        will-change: transform;
      }
      .card:hover {
        transform: translateZ(20px);
      }
      @media (max-width: 600px) {
        .topbar {
          padding: 1rem;
        }
        .logo {
          font-size: 1rem;
        }
        #connect {
          padding: 0.625rem 1rem;
          font-size: 0.8125rem;
        }
        .card {
          padding: 2rem;
        }
        main {
          padding-top: 5rem;
          gap: 2rem;
        }
      }
      .color-square {
        display: inline-block;
        width: 20px;
        height: 20px;
        vertical-align: middle;
        margin-right: 5px;
        border: 1px solid var(--border-primary);
      }
    </style>
  </head>
  <body>
    <!-- Top bar -->
    <nav class="topbar" id="topbar">
      <div class="logo">
        <img
          src="https://raw.githubusercontent.com/zama-ai/fhevm/main/docs/.gitbook/assets/fhevm-dark.png"
          alt="Zama FHE"
        />
        Secret Color Vote
      </div>
      <button id="connect" title="Connect MetaMask">
        <img
          src="https://raw.githubusercontent.com/MetaMask/metamask-extension/master/app/images/logo/metamask-fox.svg"
          alt="MetaMask"
        />
        <span>Connect</span>
      </button>
    </nav>
    <main>
      <!-- Hero section -->
      <section class="hero">
        <h1><i class="fa-solid fa-palette"></i> Secret Color Vote</h1>
        <p>Cast your vote privately with Zama FHE</p>
        <div class="subtitle">Fully Homomorphic Encryption • Privacy First</div>
      </section>
      <!-- App area with two cards -->
      <section class="app">
        <!-- Voting card -->
        <div class="card" id="voteCard">
          <h2><i class="fa-solid fa-vote-yea"></i> Cast Vote</h2>
          <div class="note">Select your preferred category and submit your encrypted vote.</div>
          <div class="inputs">
            <div class="input-wrapper">
              <label for="categorySelect">Category</label>
              <select id="categorySelect" disabled></select>
            </div>
          </div>
          <button id="castVote" class="btn btn-secondary" disabled>
            <i class="fa-solid fa-check"></i> SUBMIT VOTE
          </button>
        </div>
        <!-- Admin and histogram card -->
        <div class="card" id="adminCard">
          <h2><i class="fa-solid fa-chart-column"></i> Manage &amp; Results</h2>
          <div class="note">Close voting, publish results and view histogram.</div>
          <div class="inputs">
            <div class="input-wrapper">
              <button id="closeVoting" class="btn btn-primary" disabled>
                <i class="fa-solid fa-lock"></i> Close Voting
              </button>
            </div>
            <div class="input-wrapper">
              <button id="publishHistogram" class="btn btn-primary" disabled>
                <i class="fa-solid fa-bullhorn"></i> Publish Histogram
              </button>
            </div>
          </div>
          <div class="inputs">
            <div class="input-wrapper">
              <button id="getHistogram" class="btn btn-success" disabled>
                <i class="fa-solid fa-chart-bar"></i> Get Histogram
              </button>
            </div>
          </div>
          <div id="histogramResult" aria-live="polite"></div>
        </div>
      </section>
      <!-- Status section -->
      <section class="status">
        <div id="status" aria-live="polite">Waiting for MetaMask connection...</div>
        <div id="result" aria-live="polite"></div>
      </section>
    </main>
    <script type="module" crossorigin src="https://cdn.zama.ai/relayer-sdk-js/0.1.2/relayer-sdk-js.js"></script>
    <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm"></script>
    <script type="module">
      import { BrowserProvider, Contract } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";
      import {
        initSDK,
        createInstance,
        SepoliaConfig,
        generateKeypair,
      } from "https://cdn.zama.ai/relayer-sdk-js/0.1.2/relayer-sdk-js.js";
      const $ = (id) => document.getElementById(id);
      const [
        connectBtn,
        castVoteBtn,
        closeVotingBtn,
        publishHistogramBtn,
        getHistogramBtn,
        categorySelect,
        status,
        result,
        histogramResult,
      ] = [
        "connect",
        "castVote",
        "closeVoting",
        "publishHistogram",
        "getHistogram",
        "categorySelect",
        "status",
        "result",
        "histogramResult",
      ].map($);
      // Predefined palette of color names and hex values for categories. This array will be
      // reused across functions to assign human-friendly names to category indices and
      // style the select options accordingly.
      const colorPalette = [
        { name: "Red", value: "#ef4444" },
        { name: "Blue", value: "#3b82f6" },
        { name: "Green", value: "#10b981" },
        { name: "Yellow", value: "#f59e0b" },
        { name: "Orange", value: "#f97316" },
        { name: "Purple", value: "#8b5cf6" },
        { name: "Pink", value: "#ec4899" },
        { name: "Cyan", value: "#06b6d4" },
        { name: "Magenta", value: "#d946ef" },
        { name: "Lime", value: "#84cc16" },
        { name: "Teal", value: "#14b8a6" },
        { name: "Indigo", value: "#6366f1" },
        { name: "Violet", value: "#7c3aed" },
        { name: "Brown", value: "#92400e" },
        { name: "Black", value: "#000000" },
        { name: "White", value: "#ffffff" },
      ];
      // Card tilt effect reuse
      document.querySelectorAll(".card").forEach((card) => {
        card.addEventListener("mousemove", (e) => {
          const rect = card.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width - 0.5;
          const y = (e.clientY - rect.top) / rect.height - 0.5;
          const rotateY = x * 6;
          const rotateX = -y * 6;
          card.style.transform = `perspective(1200px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(20px)`;
        });
        card.addEventListener("mouseleave", () => {
          card.style.transform = "";
        });
      });
      // SecretColorVote contract configuration
      const CONTRACT_ADDRESS = "0xa67ba44e92AF47A950ff19d3b16D733CdFB080be";
      const KMS_ADDRESS = "0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC";
      const RELAYER_URL = "https://relayer.testnet.zama.cloud";
      const secretVoteAbi = [
        {
          inputs: [],
          name: "version",
          outputs: [{ name: "", type: "string" }],
          stateMutability: "pure",
          type: "function",
        },
        {
          inputs: [
            { name: "choiceExt", type: "bytes32" },
            { name: "proof", type: "bytes" },
          ],
          name: "vote",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "closeVoting",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "publishHistogram",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "categoriesCount",
          outputs: [{ name: "", type: "uint8" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "votingOpen",
          outputs: [{ name: "", type: "bool" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "histogramPublished",
          outputs: [{ name: "", type: "bool" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "getHistogramHandles",
          outputs: [{ name: "out", type: "bytes32[]" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "owner",
          outputs: [{ name: "", type: "address" }],
          stateMutability: "view",
          type: "function",
        },
      ];
      let provider, signer, user, relayer, contract;
      let step = 0;
      function log(msg) {
        console.log(`[${++step}] ${msg}`);
      }
      function addLoadingAnimation(btn) {
        btn.classList.add("loading");
      }
      function removeLoadingAnimation(btn) {
        btn.classList.remove("loading");
      }
      function addEncryptionAnimation(element) {
        element.classList.add("encrypt-animation");
        setTimeout(() => element.classList.remove("encrypt-animation"), 3000);
      }
      function addSuccessFlash(element) {
        element.classList.add("success-flash");
        setTimeout(() => element.classList.remove("success-flash"), 500);
      }
      async function updateStatus() {
        if (!contract) return;
        try {
          const count = await contract.categoriesCount();
          const open = await contract.votingOpen();
          const published = await contract.histogramPublished();
          result.textContent = `Categories: ${count} | Voting ${open ? "open" : "closed"} | Histogram ${published ? "published" : "not published"}`;
        } catch (e) {
          log(`Status update error: ${e.message}`);
        }
      }
      async function connectMetaMask() {
        addLoadingAnimation(connectBtn);
        log("Checking window.ethereum...");
        if (!window.ethereum || typeof window.ethereum.request !== "function") {
          status.textContent = "❌ MetaMask is not installed or does not support EIP-1193";
          log("MetaMask not found or does not support EIP-1193");
          removeLoadingAnimation(connectBtn);
          return false;
        }
        try {
          provider = new BrowserProvider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = await provider.getSigner();
          user = await signer.getAddress();
          let network = await provider.getNetwork();
          if (network.chainId !== BigInt(11155111)) {
            status.textContent = "⏳ Switching to Sepolia network...";
            log(`Incorrect network: ${network.chainId}. Requesting Sepolia (11155111)`);
            try {
              await provider.send("wallet_switchEthereumChain", [{ chainId: "0xaa36a7" }]);
              network = await provider.getNetwork();
            } catch (switchError) {
              if (switchError.code === 4902) {
                try {
                  await provider.send("wallet_addEthereumChain", [
                    {
                      chainId: "0xaa36a7",
                      chainName: "Sepolia",
                      nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
                      rpcUrls: ["https://rpc.sepolia.org"],
                      blockExplorerUrls: ["https://sepolia.etherscan.io"],
                    },
                  ]);
                  network = await provider.getNetwork();
                } catch (addError) {
                  status.textContent = "❌ Unable to add Sepolia network";
                  log(`Add network error: ${addError.message}`);
                  removeLoadingAnimation(connectBtn);
                  return false;
                }
              } else {
                status.textContent = "❌ Please switch to Sepolia network";
                log(`Network switch error: ${switchError.message}`);
                removeLoadingAnimation(connectBtn);
                return false;
              }
            }
            if (network.chainId !== BigInt(11155111)) {
              status.textContent = "❌ Please switch to Sepolia network";
              log(`Failed to switch network: ${network.chainId}`);
              removeLoadingAnimation(connectBtn);
              return false;
            }
          }
          status.textContent = `✅ Connected: ${user.slice(0, 6)}...${user.slice(-4)}`;
          log(`Connected account: ${user}`);
          connectBtn.innerHTML = `<img src="https://raw.githubusercontent.com/MetaMask/metamask-extension/master/app/images/logo/metamask-fox.svg" alt="MetaMask"><span>${user.slice(0, 6)}...${user.slice(-4)}</span>`;
          connectBtn.disabled = true;
          document.getElementById("topbar").classList.add("connected");
          // Enable form inputs and buttons
          categorySelect.disabled = false;
          castVoteBtn.disabled = false;
          closeVotingBtn.disabled = false;
          publishHistogramBtn.disabled = false;
          getHistogramBtn.disabled = false;
          addSuccessFlash(status);
          log("Initializing Relayer SDK...");
          await initSDK();
          log("Relayer SDK initialized");
          const relayerConfig = {
            ...SepoliaConfig,
            network: window.ethereum,
            relayerUrl: RELAYER_URL,
            debug: true,
          };
          const code = await provider.getCode(KMS_ADDRESS);
          if (code === "0x") {
            throw new Error(`KMS contract not found at address: ${KMS_ADDRESS}`);
          }
          log(`KMS contract exists: ${KMS_ADDRESS}, code length: ${code.length} bytes`);
          log("Creating relayer...");
          relayer = await createInstance(relayerConfig);
          log("Relayer ready");
          log("Creating contract instance...");
          contract = new Contract(CONTRACT_ADDRESS, secretVoteAbi, signer);
          log(`Contract initialized: ${CONTRACT_ADDRESS}`);
          const version = await contract.version();
          log(`Contract version: ${version}`);
          // Determine if the connected user is the owner of the contract. Only the owner can close voting and publish the histogram.
          try {
            const owner = await contract.owner();
            const isOwner = owner.toLowerCase() === user.toLowerCase();
            closeVotingBtn.disabled = !isOwner;
            publishHistogramBtn.disabled = !isOwner;
            // Optionally hide admin buttons completely for non-owners
            if (!isOwner) {
              closeVotingBtn.style.display = "none";
              publishHistogramBtn.style.display = "none";
            }
          } catch (err) {
            log(`Failed to fetch owner: ${err.message}`);
          }
          // Populate categories select with color names instead of generic labels
          const categories = await contract.categoriesCount();
          categorySelect.innerHTML = "";
          for (let i = 0; i < categories; i++) {
            const paletteIndex = i % colorPalette.length;
            const color = colorPalette[paletteIndex];
            const opt = document.createElement("option");
            opt.value = i;
            opt.innerHTML = `<span class="color-square" style="background-color: ${color.value};"></span> ${color.name}`;
            opt.style.backgroundColor = color.value;
            opt.style.color = "#ffffff";
            opt.style.fontWeight = "bold";
            categorySelect.appendChild(opt);
          }
          await updateStatus();
          removeLoadingAnimation(connectBtn);
          return true;
        } catch (e) {
          status.textContent = `❌ Connection error: ${e.message}`;
          log(`Connection error: ${e.message}`);
          removeLoadingAnimation(connectBtn);
          return false;
        }
      }
      window.addEventListener("load", () => {
        log("Page loaded, attaching handler to MetaMask button");
        connectBtn.onclick = connectMetaMask;
      });
      // Cast vote
      castVoteBtn.onclick = async () => {
        if (!relayer || !contract) {
          status.textContent = "❌ Connect MetaMask first";
          log("MetaMask not connected");
          return;
        }
        const choice = Number(categorySelect.value || 0); // ensure it's a JS number for add8
        if (choice < 0 || choice > 255 || Number.isNaN(choice)) {
          status.textContent = "❌ Invalid category";
          log(`Invalid category: ${choice}`);
          return;
        }
        castVoteBtn.disabled = true;
        addLoadingAnimation(castVoteBtn);
        addEncryptionAnimation(categorySelect);
        status.textContent = "⏳ Casting vote...";
        try {
          log(`Choice: ${choice}`);
          const buf = relayer.createEncryptedInput(CONTRACT_ADDRESS, user);
          buf.add8(choice);
          const { handles, inputProof } = await buf.encrypt();
          const hChoice = handles[0];
          const proof = inputProof;
          log(`hChoice: ${String(hChoice)}`);
          log(`proof(bytes): ${proof.length}`);
          await contract.vote.staticCall(hChoice, proof);
          log("Static call passed");
          const tx = await contract.vote(hChoice, proof);
          log(`txHash: ${tx.hash}`);
          await tx.wait();
          status.textContent = "✅ Vote submitted";
          result.textContent = `🎉 Vote cast (tx: ${tx.hash})`;
          addSuccessFlash(result);
        } catch (e) {
          status.textContent = `❌ Error: ${e.message}`;
          log(`Vote error: ${e.message}`);
        } finally {
          castVoteBtn.disabled = false;
          removeLoadingAnimation(castVoteBtn);
          await updateStatus();
        }
      };
      // Close voting
      closeVotingBtn.onclick = async () => {
        if (!contract) {
          status.textContent = "❌ Connect MetaMask first";
          log("MetaMask not connected");
          return;
        }
        closeVotingBtn.disabled = true;
        addLoadingAnimation(closeVotingBtn);
        status.textContent = "⏳ Closing voting...";
        try {
          const tx = await contract.closeVoting();
          log(`closeVoting tx: ${tx.hash}`);
          await tx.wait();
          status.textContent = "✅ Voting closed";
          addSuccessFlash(status);
        } catch (e) {
          status.textContent = `❌ Error: ${e.message}`;
          log(`Close voting error: ${e.message}`);
        } finally {
          closeVotingBtn.disabled = false;
          removeLoadingAnimation(closeVotingBtn);
          await updateStatus();
        }
      };
      // Publish histogram
      publishHistogramBtn.onclick = async () => {
        if (!contract) {
          status.textContent = "❌ Connect MetaMask first";
          log("MetaMask not connected");
          return;
        }
        publishHistogramBtn.disabled = true;
        addLoadingAnimation(publishHistogramBtn);
        status.textContent = "⏳ Publishing histogram...";
        try {
          const tx = await contract.publishHistogram();
          log(`publishHistogram tx: ${tx.hash}`);
          await tx.wait();
          status.textContent = "✅ Histogram published";
          addSuccessFlash(status);
        } catch (e) {
          status.textContent = `❌ Error: ${e.message}`;
          log(`Publish histogram error: ${e.message}`);
        } finally {
          publishHistogramBtn.disabled = false;
          removeLoadingAnimation(publishHistogramBtn);
          await updateStatus();
        }
      };
      // Get histogram counts
      getHistogramBtn.onclick = async () => {
        if (!relayer || !contract) {
          status.textContent = "❌ Connect MetaMask first";
          log("MetaMask not connected");
          return;
        }
        getHistogramBtn.disabled = true;
        addLoadingAnimation(getHistogramBtn);
        status.textContent = "⏳ Retrieving histogram...";
        try {
          const handles = await contract.getHistogramHandles();
          log(`Handles: ${JSON.stringify(handles)}`);
          if (!handles || handles.length === 0) {
            status.textContent = "❌ No histogram available";
            log("No histogram handles returned");
          } else {
            // Histogram is available only after publishHistogram() has been called by the owner.
            const published = await contract.histogramPublished();
            if (!published) {
              status.textContent = "❌ Histogram is not published yet. Ask owner to press “Publish Histogram”.";
              log("Histogram not published");
            } else {
              // Public decryption: anyone can decrypt without a signature.
              const out = await relayer.publicDecrypt(handles);
              log(`publicDecrypt output: ${Array.isArray(out) ? "array" : typeof out}`);
              // out can be either an array or an object depending on SDK version
              let countsArr;
              if (Array.isArray(out)) {
                countsArr = out;
              } else {
                countsArr = handles.map((h) => out[h]);
              }
              const counts = countsArr.map((v) => {
                try {
                  return BigInt(v).toString();
                } catch {
                  return "?";
                }
              });
              const display = counts
                .map((c, i) => {
                  const paletteIndex = i % colorPalette.length;
                  const color = colorPalette[paletteIndex];
                  return `${color.name}: ${c}`;
                })
                .join(" | ");
              histogramResult.textContent = display;
              status.textContent = "✅ Histogram decrypted";
              addSuccessFlash(histogramResult);
            }
          }
        } catch (e) {
          status.textContent = `❌ Error: ${e.message}`;
          log(`Get histogram error: ${e.message}`);
        } finally {
          getHistogramBtn.disabled = false;
          removeLoadingAnimation(getHistogramBtn);
          await updateStatus();
        }
      };
    </script>
  </body>
</html>
